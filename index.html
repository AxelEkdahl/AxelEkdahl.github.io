  <!DOCTYPE html>

  <html lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title> DOM XSS Tests</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
  </head>
  <body>

    <h1 align="center">DOM-Based XSS Test Cases</h1>

    <h3 align="center">This web presents a set of sources and sinks combinations <br>
      that could potentially cause DOM-Based XSS vulnerabilities</h3>
      <hr>
      <div class="container-fluid">
        <div class="row">
          <div class="col-md-12">
            <h1>Source: <br> document.URL</h1>

            <table class="table table-striped">
              <thead>
                <tr>
                  <th class="col-md-1">Sink</th>
                  <th class="col-md-3">Sample attack</th>
                  <th class="col-md-4">Description/Solution</th>
                  <th class="col-md-1 text-center">Firefox</th>
                  <th class="col-md-1 text-center">Chrome</th>
                  <th class="col-md-1 text-center">Edge</th>
                  <th class="col-md-1 text-center">IE</th>  
                </tr>
              </thead>
              <tbody>

                <tr>
                  <td><p>Document.write</p></td>
                  <td><a href="static/document.URL/document_write.html#&lt;img src=foo onerror=alert(123)&gt;">document_write.html#&lt;img src=foo onerror=alert(123)&gt;</a></td>
                  <td><b>document.write</b> is used with an unfiltered value from the source document.URL. Both Firefox and Chrome encode the url making this attack unsuccessful furthermore Chrome XSS auditor also blocks this operation. Neither IE or Edge perform URL encoding suffering from this flaw in the webpage code.
                    <hr>
                  In order to fix this vulnerability the developer should replace the document.write API call
                  as it is considered an unsafe API and should be avoided. Or if it is really needed perform client side encoding for html context.
                  </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>

                <tr>
                  <td><p>element.innerHTML</p></td>
                  <td><a href="static/document.URL/innerhtml.html#&lt;img src=foo onerror=alert(123)&gt;">innerhtml.html#&lt;img src=foo onerror=alert(123)&gt;</a></td>
                  <td><b>element.innerhtml</b> is used with an unfiltered value from the sourcedocument.URL. In this case the XSS auditor from Google Chrome does not block the attack.<hr>
                    In order to fix this dom-xss flaw the developer should instead use a safe Javascript API like element.innertText instead
                    of innerHTMl, making sure the user input is rendered only as text.</td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>

                <tr>
                  <td><p>element.SetAttribute()</p></td>
                  <td><a href="static/document.URL/setattribute.html?url=javascript:alert(1)">setattribute.html?url=javascript:alert(1)</a></td>
                  <td><b>element.setAttribute(href,)</b> is used with an unfiltered value from the source document.URL. Since javascript: is a valid scheme for the href attribute all the browsers will execute any user input code that gets inserted into this attribute.
                    <hr>
                    A solution to this issue would be to either sanitize the user input, or avoid the use of the setAttribute method with 
                    user input data.</td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>

                <tr>
                  <td><p>Eval()</p></td>
                  <td><a href="static/document.URL/eval.html?pid=3');eval(String.fromCharCode(97,108,101,114,116,40,39,104,105,39,41))//">eval.html?pid=3');eval(String.fromCharCode(97,108,101,114,116,40,39,104,105,39,41))//</a></td>
                  <td><b>eval</b> is used here with an unfiltered value from the source document.URL. Since eval evaluates the string given as code any user input value supplied here can be executed code and there is no safe way to avoid this xss flaw.
                    <hr>
                    Eval should not be used with user controlled input.</td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>

                <!--<tr>
                  <td><p>ScriptElement.onclick()</p></td>
                  <td><a href="static/document.URL/onclick.html?pid=3');eval(String.fromCharCode(97,108,101,114,116,40,39,104,105,39,41))//">onclick.html?pid=3');eval(String.fromCharCode(97,108,101,114,116,40,39,104,105,39,41))//</a></td>
                  <td><b>element.onclick</b> is here used with an unfiltered value from the source document.URL. Any attribute </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>-->

                <tr>
                  <td><p>Location.replace</p></td>
                  <td><a href="static/document.URL/locationreplace.html?q=javascript:alert()">locationreplace.html?q=javascript:alert()</a></td>
                  <td><b>location.replace</b> is used here with an unfiltered value from the source document.URL. Browser encoding of the url 
                    does not help prevent this attack, since URL encoding does not prevent from using the javascript: scheme to run user scripts
                    <hr>
                    The most effective way to avoid such vulnerability is to avoid the use of dynamic redirections using the user introduced data</td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>

              </tbody>
            </table>

            <h1>Source: <br> document.documentURI</h1>
            <table class="table table-striped">
              <thead>
                <tr>
                  <th class="col-md-1">Sink</th>
                  <th class="col-md-3">Sample attack</th>
                  <th class="col-md-4">Description/Solution</th>
                  <th class="col-md-1 text-center">Firefox</th>
                  <th class="col-md-1 text-center">Chrome</th>
                  <th class="col-md-1 text-center">Edge</th>
                  <th class="col-md-1 text-center">IE</th>  
                </tr>

                <tr>
                  <td><p>Document.write</p></td>
                  <td><a href="static/document.documentURI/document_write.html#&lt;img src=foo onerror=alert(123)&gt;">document_write.html#&lt;img src=foo onerror=alert(123)&gt;</a></td>
                  <td>
                    <p>
                      <b>document.write</b> with an unfiltered value from document.documentURI. No encoding or escaping is done which means the sink will run any executable injection the attacker decides to include in the URI. This attack is although blocked in Chrome and Firefox.
                    </p>
                    <hr />
                    <p>
                      This sink should not be used. Instead the developer could use javascript methods such as element.innerText and element.appendChild which is adding the content to the webpage but without having the content being parsed as executable code.
                    </p>
                     
                  </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>

                <tr>
                  <td><p>element.innerHTML</p></td>
                  <td><a href="static/document.documentURI/innerhtml.html#&lt;img src=foo onerror=alert(123)&gt;">innerhtml.html#&lt;img src=foo onerror=alert(123)&gt;</a></td>
                  <td>
                    <p>
                    <b>element.innerhtml</b> is used here with an unfiltered value from document.documentURI. HTML5 specifies that a &lt;script&gt; tag inserted via innerHTML should not execute but other types of tags can be injected here making this API unsafe.
                    </p>
                    <hr/>
                    <p>
                      The developer could replace this with safe javascript methods as element.innerText or element.appendChild forcing the browser to render the content as text
                    </p>
                  </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>

                <tr>
                  <td><p>Eval()</p></td>
                  <td><a href="static/document.documentURI/eval.html?pid=3');eval(String.fromCharCode(97,108,101,114,116,40,39,104,105,39,41))//">eval.html?pid=3');eval(String.fromCharCode(97,108,101,114,116,40,39,104,105,39,41))//</a></td>
                  <td>
                  <p>
                    <b>eval</b> is used with an unfiltered value from the sink document.documentURI Since eval evaluates the string given as code any user input value supplied here can be executed code and there is no safe way to avoid this xss flaw.
                  </p>
                    <hr/>
                  <p>
                    Eval should not be used with user controlled input, there are no completely safe ways to avoid malicious code to be injected into eval.
                  </p></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>
              </thead>
              <tbody>


              </tbody>
            </table>


            <h1>Source: <br> location.href</h1>
            <table class="table table-striped">
              <thead>
                <tr>
                  <th class="col-md-1">Sink</th>
                  <th class="col-md-3">Sample attack</th>
                  <th class="col-md-4">Description/Solution</th>
                  <th class="col-md-1 text-center">Firefox</th>
                  <th class="col-md-1 text-center">Chrome</th>
                  <th class="col-md-1 text-center">Edge</th>
                  <th class="col-md-1 text-center">IE</th>  
                </tr>
              </thead>
              <tbody>
                <td><p>document.write</p></td>
                <td>
                  <a href="static/location.href/document.write.html?default=<script>alert('hi')</script>">document.write.html?default=&lt;script&gt;alert(hi)&lt;/script&gt;</a>
                  <td>
                    <p>This example simulates an attack were the target user is given a malicious link to click on. The target website are using GET requests containing the parameter 'default' to populate a form selection. The form is created with javascript and the source. <b> document.write</b> is used with a decoded input value from <b>location.href</b>.</p>
                    <hr />
                    <p>Here we see an example of when sanitization would be of great help. The url from the beginning is urlencoded which later on will be decoded before reaching the sink <b>document.write</b>. Therefore, the malicious code will get exectued anyway. Proper sanitization should be done with a combination of html escaping between the decoding and when the sink retrieves the content. Another solution would be to use <b>element.innerText </b> as a sink instead of <b>document.write</b>. </p>
                  </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tbody>
              </table>

              <h1>Source: <br> location.search</h1>
              <table class="table table-striped">
                <thead>
                  <tr>
                    <th class="col-md-1">Sink</th>
                    <th class="col-md-3">Sample attack</th>
                    <th class="col-md-4">Description/Solution</th>
                    <th class="col-md-1 text-center">Firefox</th>
                    <th class="col-md-1 text-center">Chrome</th>
                    <th class="col-md-1 text-center">Edge</th>
                    <th class="col-md-1 text-center">IE</th>  
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><p>document.write</p></td>
                    <td><a href="static/location.search/document.write.html?<svg/onload=alert(1)">document.write.html?&lt;svg/onload=alert(1)</a></td>
                    <td>
                      <p>
                        This test case simulates an attack vector that is used by taking advantage of the svg element in html that is used for creating grafical vectors. This is a common attack vector to used since the attribute onload allows javascript to be executed. Here the sink being <b>document.write</b> and it is used with unfiltered value from the source <b>location.search</b></p>
                      <hr />
                      <p>
                        The solution to this is to perform html escaping before the content reach the sink in order to prevent the svg element to be executed.                       
                      </p>
                    </td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  </tr>
                  <tr>
                  <td><p>window.setInterval</p></td>
                    <td><a href="static/location.search/setInterval.html">setInterval.html</a></td>
                    <td>
                      <p>
                        This example illustrates a search page which not have interaction towards a server but instead could be a word count at the current page. The result is desired to have some delay before being presented, therefore the developer using <b>window.setInterval</b>. This sink is populated with an unfiltered value from location.search</p>
                      <p>
                        This is a typical sink that never should be used due to the reason that it can interpret string values into executable code. Hence making encodong useless. Even if the input being sanitized it is not entirely safe, since it is hard to cover all possible combinations of threats. This sink should never be used with user controlled input.
                      </p>

                      <hr />
                    </td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  </tr>

                  </tbody>
                </table>

                <h1>Source: <br> location.hash</h1>
                <table class="table table-striped">
                  <thead>
                    <tr>
                      <th class="col-md-1">Sink</th>
                      <th class="col-md-3">Sample attack</th>
                      <th class="col-md-4">Description/Solution</th>
                      <th class="col-md-1 text-center">Firefox</th>
                      <th class="col-md-1 text-center">Chrome</th>
                      <th class="col-md-1 text-center">Edge</th>
                      <th class="col-md-1 text-center">IE</th>  
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>location.replace</td>
                      <td><a href="static/location.hash/location.replace.html#Javascript:alert(0)">location.html#Javascript:alert(0)</a></td>
                      <td>
                        <p>
                          In this test case the <b>location.replace </b> is used with unfiltered value from the source <b>location.hash</b>. 
                        </p>
                        <hr />
                        <p> 
                          The best protection against this would be to move the functionality of redirect a user from  client side to the server side. This with a combination of not having user controlled input data going into the sink. However, if the functionality will be kept on client side proper sanitization needs to be done to prevent the Javascript: scheme.</p>
                        </td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>


                    </tr>
                    <tr>
                      <td>document.write</td>
                      <td><a href="static/location.hash/document.write.html#<script>alert()</script>">document.write.html#&lt;script&gt;alert()&lt;/script&gt;</a></td>
                      <td>
                          <p>In this test case the sink <b>document.write </b> is used with unfiltered value from the source <b>location.hash</b> without any encoding or validation being used.</p>
                          <hr />
                          <p>This sink should be a voided as much as possible. Specifically for this test case the XSS Auditor understands there is malicious content being sent (the &lt;script&gt; tags added in the end of the link) and hence blocking the execution. Firefox understands this as well but instead encodes the content. If this sink being used the developer need to make sure to do proper encoding or validation.
                      </td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                     </tr>
                     <tr>
                      <td>setTimeout</td>
                      <td><a href="static/location.hash/document.setTimeout.html#timer=alert()">setTimeout.html#timer=alert()</a></td>
                      <td>
                        <p>
                          In this test case the <b>document.setTimeout</b> is given unfiltered content, from the hashtag in the url, through an image's onload attribute.</p>
                        <hr />
                        <p>
                          This sink is a common sink prone to XSS attacks and should not be used. This since it can execute content of typ string into code. Hence developers should not use this sink with user controlled input. </p>
                      </td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                     </tr>

                    </tbody>
                  </table>

                  <h1>Source: <br> PostMessage</h1>
                  <table class="table table-striped">
                    <thead>
                     <tr>
                      <th class="col-md-1">Sink</th>
                      <th class="col-md-3">Sample attack</th>
                      <th class="col-md-4">Description/Solution</th>
                      <th class="col-md-1 text-center">Firefox</th>
                      <th class="col-md-1 text-center">Chrome</th>
                      <th class="col-md-1 text-center">Edge</th>
                      <th class="col-md-1 text-center">IE</th>   
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>element.innerHTML</td>
                      <td><a href="static/postmessage/PostMessage.html ">PostMessage.html</a></td>
                      <td>
                        <p>Here the HTML5 method <b> PostMessage </b>is used to bypass the Same Origin Policy through a loaded iframe. The PostMessage is a cross-document messaging that allows communication between different domains. This can be used by attackers to form attack vectors. The attacker can create an iframe on his own website that loads the target website. Throught the iframe the attacker can  send malicious content to manipulate the DOM of the target website so that sensitive information can be retrieved. In this test case an alert is injected in the target DOM to successfully retrieve the cookie of the target website</p>
                        <hr />
                        <p>
                          The reason why this exploit is possible to do is because the target website does not do any sanitization or encoding before providing the data to the sink <b>element.innerHTML</b>. If this would be done properly this attack would no longer be a threat. </p>
                      </td>
                       <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                      <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    </tr>
                  </tbody>
              </table>

              <h1>Source: <br> window.name</h1>
              <table class="table table-striped">
                <thead>
                  <tr>
                    <th class="col-md-1">Sink</th>
                    <th class="col-md-3">Sample attack</th>
                    <th class="col-md-4">Description/Solution</th>
                    <th class="col-md-1 text-center">Firefox</th>
                    <th class="col-md-1 text-center">Chrome</th>
                    <th class="col-md-1 text-center">Edge</th>
                    <th class="col-md-1 text-center">IE</th>   
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><p>element.innerHTML</p></td>
                    <td><a href="static/window.name/innerhtml.html">innerhtml.html</a></td>
                    <td><p><b>element.innertHTML </b> receives user input from the source window.name, this is a common mistake
                      by developers if they forget to use the 'var' keyword when declaring a variable called name. This is a specially dangerous
                      dom-xss flaw since the window.name attribute will traverse through different domains.
                      <hr>
                      In order to fix this issue developers should avoid the use of the unsafe javascript element.innerHTML and use instead <b>element.innerText</b> or in such case perform sanitization / encoding of the name introduced by the user.
                    </td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                    <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  </tr>

                </tbody>
              </table>

              <h1>Source: <br> window.top</h1>
              <table class="table table-striped">
                <thead>
                  <tr>
                    <th class="col-md-1">Sink</th>
                    <th class="col-md-3">Sample attack</th>
                    <th class="col-md-4">Description/Solution</th>
                    <th class="col-md-1 text-center">Firefox</th>
                    <th class="col-md-1 text-center">Chrome</th>
                    <th class="col-md-1 text-center">Edge</th>
                    <th class="col-md-1 text-center">IE</th>   
                  </tr>
                </thead>
                <tbody>


                </tbody>
              </table>


              <h1>Source: <br> document.referrer</h1>
              <table class="table table-striped">
                <thead>
                  <tr>
                    <th class="col-md-1">Sink</th>
                    <th class="col-md-3">Sample attack</th>
                    <th class="col-md-4">Description/Solution</th>
                    <th class="col-md-1 text-center">Firefox</th>
                    <th class="col-md-1 text-center">Chrome</th>
                    <th class="col-md-1 text-center">Edge</th>
                    <th class="col-md-1 text-center">IE</th>   
                  </tr>
                </thead>
                <tbody>
                 <tr>
                  <td><p>element.innerHTML</p></td>
                  <td><a href="static/document.referrer/innerHtml.html?<img%20src=x%20onerror=Javascript:alert(9)>?" >innerHtml.html?q=javascript:alert()</a></td>
                  <td><p>Test case where the value in the referrer object is decoded into <b>document.innerHTML</b> to let the user be aware of the previous visited page. The <b>document.referrer</b> object keeps track of the previously visited domain and hence if user controlled parameters in the url aren't handled properly the website will be prone to DOM XSS when using this attribute. </p>
                  <hr />
                   <p>Instead of using unsafe sinks such as <b>element.innerHTML</b> safe API's such as <b>element.innerText</b> should be used. Also sanitization could be used to properly handle any malicious injection, e.g. sanitization of the keyword Javascript: or script tags.</p>
                  </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                </tr>
              </tbody>
            </table>

            <h1>Source: <br> localStorage</h1>
            <table class="table table-striped">
              <thead>
                <tr>
                  <th class="col-md-1">Sink</th>
                  <th class="col-md-3">Sample attack</th>
                  <th class="col-md-4">Description/Solution</th>
                  <th class="col-md-1 text-center">Firefox</th>
                  <th class="col-md-1 text-center">Chrome</th>
                  <th class="col-md-1 text-center">Edge</th>
                  <th class="col-md-1 text-center">IE</th>   
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><p>Document.writeln</p></td>
                  <td><a href="static/localStorage/document_writeln.html">document_writeln.html</a></td>
                  <td>
                    <p>
                    <b>document.writeln</b> is used with an unfiltered value from localStorage. LocalStorage was introduced with HTML5. Before data had to be stored in cookies and it was included in every request affecting the website performance.This new functionality bring a new type of stored source into play in dom-xss attacks. Both IE and Edge are not affected since they do not implement localStorage yet.
                  </p>
                  <hr/>
                  <p>
                    As with other types of storage xss the user input should be validated and output encoding should be performed when the value is retrieved 
                  </p>
                </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:red;">clear</i></td>

                </tr>

              </tbody>
            </table>

            <h1>Source: <br> document.cookie</h1>
            <table class="table table-striped">
              <thead>
                <tr>
                  <th class="col-md-1">Sink</th>
                  <th class="col-md-3">Sample attack</th>
                  <th class="col-md-4">Description/Solution</th>
                  <th class="col-md-1 text-center">Firefox</th>
                  <th class="col-md-1 text-center">Chrome</th>
                  <th class="col-md-1 text-center">Edge</th>
                  <th class="col-md-1 text-center">IE</th>   
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><p>Document.write</p></td>
                  <td><a href="static/document.cookie/document_write.html">document_write.html</a></td>
                  <td>
                    <p>
                    <b>document.write</b> is used with an unfiltered value from a cookie. Cookies are also a dangerous source of input.
                  </p>
                  <hr/>
                  <p>
                    As with other types of storage xss the user input should be validated and output encoding should be performed when the value is retrieved 
                  </p>
                </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>

                </tr>
              </tbody>
            </table>

            <h1>Some real examples:</h1>
            <table class="table table-striped">
              <thead>
                <tr>
                  <th class="col-md-1">Sink</th>
                  <th class="col-md-3">Sample attack</th>
                  <th class="col-md-4">Description/Solution</th>
                  <th class="col-md-1 text-center">Firefox</th>
                  <th class="col-md-1 text-center">Chrome</th>
                  <th class="col-md-1 text-center">Edge</th>
                  <th class="col-md-1 text-center">IE</th>   
                </tr>
              </thead>
              <tbody>

                <tr>
                  <td><p>Ember js Dom-XSS</p></td>
                  <td><a href="static/real/emberjs.html?query=&lt;img src=x onerror=alert(0)&gt;">emberjs.html?query=&lt;img src=x onerror=alert(0)&gt;</a></td>
                  <td>
                    <p>
                    Real example based on a vulnerability found in the EmberJS framework with an unfiltered value from location.href. The use of decodeURIComponent opens up opportunities for dom-xss attacks.
                  </p>
                  <hr/>
                  <p>
                    Developers should take care when performing criticall operations like decodeURIComponent since it opens new chances of dom-xss attacks. THe unsafe sink innerHTML should be replaced or otherwise sanitize/encode the user input.
                  </p>
                  </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>

                </tr>

                <tr>
                  <td><p>Twitter hashbang dom-xss</p></td>
                  <td><a href="static/real/twitter.html#!javascript:alert(1)">twitter.html/#!javascript:alert(1)</a></td>
                  <td>
                    <p>
                    Real example based on a vulnerability found in Twitter using the old Hashbang method with an unfiltered value from location.href. The hashbang method was once used to tell Google how to index the page, since search engines dont execute the javascript in the pages 
                  </p>
                  <hr/>
                  <p>
                    Nowadays the use of pushstate has made this hashbang technique obsolete. Back then twitter employed sanitization of the input in order to avoid this dom-xss attack.
                  </p>
                  </td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>
                  <td class="text-center"><i class="material-icons" style="font-size:24px;color:green;">done</i></td>

                </tr>

              </tbody>
            </table>

          </div>
        </div>
      </div>

      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
      <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
      
    </body>
    </html>